CCS PCH C Compiler, Version 4.140, 8854               18-nov-14 18:16

               Filename:   C:\Users\Murillo\Desktop\Microcontroler\Main.lst

               ROM used:   1436 bytes (4%)
                           Largest free fragment is 31328
               RAM used:   44 (2%) at main() level
                           44 (2%) worst case
               Stack:     1 worst case (0 in main + 1 for interrupts)

*
0000:  GOTO   01FE
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   00AE
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES PLL1                     //No PLL PreScaler 
.................... #FUSES CPUDIV1                  //No System Clock Postscaler 
.................... #FUSES HS                       //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=20000000) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1) 
....................  
....................  
.................... //Pinos sensores da Garra 
.................... #define Aberta pin_a4 
.................... #define Fechada pin_a5 
.................... #define LedGarra pin_d0 
.................... //Pinos enable para Pontes-H 
.................... #define Enable_0 pin_d2 
.................... #define Enable_1 pin_d3 
.................... #define Enable_2 pin_c4 
.................... #define Enable_3 pin_c5 
.................... //Leds de Informação 
.................... #define Led_B pin_c0               // Azul 
.................... #define Led_G pin_c1               // Verde 
.................... #define Led_R pin_c2               // Vermelho 
.................... /*Pinos de acionamento de motores 
.................... das juntas*/ 
.................... #define Junta0E pin_b7 
.................... #define Junta0D pin_b6 
.................... #define Junta1E pin_b5 
.................... #define Junta1D pin_b4 
.................... #define Junta2E pin_b3 
.................... #define Junta2D pin_b2 
.................... #define Junta3E pin_b1 
.................... #define Junta3D pin_b0 
.................... /*Pinos de acionamento de motores 
.................... da garra*/ 
.................... #define GarraA pin_d7 
.................... #define GarraF pin_d6 
....................  
.................... /*Variável de faixa de tolerância 
....................    para posicionamento das juntas  
....................    (por unidade de Bits do ADC)*/ 
....................    unsigned int8 Range=4; 
....................    //Variáveis auxiliares para sinalização de parada(chegada no ponto)  
....................    int1 a=0; int1 b=0; int1 c=0; int1 d=0; int1 e=0; 
....................    //Variável auxiliar para comunicação de parada, inicia em 1 para não enviar o sinal na primeira iteração 
....................    int1 z=1; 
....................    /*Variáveis para armazenamento dos valores  
....................    dos sensores das juntas*/ 
....................    unsigned int8 Junta0_Atual; 
....................    unsigned int8 Junta0_Desejado; 
....................    unsigned int8 Junta1_Atual; 
....................    unsigned int8 Junta1_Desejado; 
....................    unsigned int8 Junta2_Atual; 
....................    unsigned int8 Junta2_Desejado; 
....................    unsigned int8 Junta3_Atual; 
....................    unsigned int8 Junta3_Desejado; 
....................    int1 Garra_desejado=0;              // 1=Fechada, 0=Aberta 
....................    /* Variáveis auxiliares para  
....................    verificação de comandos em uma  
....................    nova entrada de dados desejados*/ 
....................    unsigned int8 Aux_0; 
....................    unsigned int8 Aux_1; 
....................    unsigned int8 Aux_2; 
....................    unsigned int8 Aux_3; 
....................  
.................... #int_RDA //Importante Limpar o Buffer! Caso contrário o promgrama fica preso na interrupção 
.................... void RDA(void) 
.................... {  
....................          //Armazenando dados lidos do buffer em variáveis auxiliares 
....................          Aux_0 = getc(); 
00AE:  BTFSS  F9E.5
00B0:  BRA    00AE
00B2:  MOVFF  FAE,23
....................          Aux_1 = getc(); 
00B6:  BTFSS  F9E.5
00B8:  BRA    00B6
00BA:  MOVFF  FAE,24
....................          Aux_2 = getc(); 
00BE:  BTFSS  F9E.5
00C0:  BRA    00BE
00C2:  MOVFF  FAE,25
....................          Aux_3 = getc(); 
00C6:  BTFSS  F9E.5
00C8:  BRA    00C6
00CA:  MOVFF  FAE,26
....................          //output_high(Led_R);            //Quando recebe dado aciona led na cor azul 
....................          //output_high(Led_G); 
....................          //output_low(Led_B); 
....................           
....................          a=0; b=0; c=0; d=0; e=0;   //zera todos contadores de parada 
00CE:  BCF    1A.0
00D0:  BCF    1A.1
00D2:  BCF    1A.2
00D4:  BCF    1A.3
00D6:  BCF    1A.4
....................          
....................          //Testando se os novos dados colhidos são comandos espefícos 
....................          if((char)Aux_0 == 's' && (char)Aux_1 == 't' && (char)Aux_2 == 'o' && (char)Aux_3 == 'p')        //Comando para parar acionamento 
00D8:  MOVF   23,W
00DA:  SUBLW  73
00DC:  BNZ   0124
00DE:  MOVF   24,W
00E0:  SUBLW  74
00E2:  BNZ   0124
00E4:  MOVF   25,W
00E6:  SUBLW  6F
00E8:  BNZ   0124
00EA:  MOVF   26,W
00EC:  SUBLW  70
00EE:  BNZ   0124
....................          {   
....................             output_low(Junta0D);output_low(Junta1D);output_low(Junta2D);output_low(Junta3D); 
00F0:  BCF    F93.6
00F2:  BCF    F8A.6
00F4:  BCF    F93.4
00F6:  BCF    F8A.4
00F8:  BCF    F93.2
00FA:  BCF    F8A.2
00FC:  BCF    F93.0
00FE:  BCF    F8A.0
....................             output_low(Junta0E);output_low(Junta1E);output_low(Junta2E);output_low(Junta3E); 
0100:  BCF    F93.7
0102:  BCF    F8A.7
0104:  BCF    F93.5
0106:  BCF    F8A.5
0108:  BCF    F93.3
010A:  BCF    F8A.3
010C:  BCF    F93.1
010E:  BCF    F8A.1
....................             Junta0_Desejado = Junta0_Atual; 
0110:  MOVFF  1B,1C
....................             Junta1_Desejado = Junta1_Atual; 
0114:  MOVFF  1D,1E
....................             Junta2_Desejado = Junta2_Atual; 
0118:  MOVFF  1F,20
....................             Junta3_Desejado = Junta3_Atual; 
011C:  MOVFF  21,22
....................             z=0; 
0120:  BCF    1A.5
....................          } 
....................          //Comando para enviar dados dos sensores 
....................          else if((char)Aux_0 == 'r' && (char)Aux_1 == 'e' && (char)Aux_2 == 'a' && (char)Aux_3 == 'd')    
0122:  BRA    01F8
0124:  MOVF   23,W
0126:  SUBLW  72
0128:  BNZ   0160
012A:  MOVF   24,W
012C:  SUBLW  65
012E:  BNZ   0160
0130:  MOVF   25,W
0132:  SUBLW  61
0134:  BNZ   0160
0136:  MOVF   26,W
0138:  SUBLW  64
013A:  BNZ   0160
....................          {  
....................             printf("%c%c%c%c",Junta0_Atual,Junta1_Atual,Junta2_Atual,Junta3_Atual); 
013C:  MOVF   1B,W
013E:  BTFSS  F9E.4
0140:  BRA    013E
0142:  MOVWF  FAD
0144:  MOVF   1D,W
0146:  BTFSS  F9E.4
0148:  BRA    0146
014A:  MOVWF  FAD
014C:  MOVF   1F,W
014E:  BTFSS  F9E.4
0150:  BRA    014E
0152:  MOVWF  FAD
0154:  MOVF   21,W
0156:  BTFSS  F9E.4
0158:  BRA    0156
015A:  MOVWF  FAD
....................             z=1; //z deve ser 1 pois após o comando "read" dados não devem ser retornados  
015C:  BSF    1A.5
....................          } 
....................          //Comando para fechar garra 
....................          else if((char)Aux_0 == 'g' && (char)Aux_1 == 'r' && (char)Aux_2 == 'a' && (char)Aux_3 == 'b')    
015E:  BRA    01F8
0160:  MOVF   23,W
0162:  SUBLW  67
0164:  BNZ   017E
0166:  MOVF   24,W
0168:  SUBLW  72
016A:  BNZ   017E
016C:  MOVF   25,W
016E:  SUBLW  61
0170:  BNZ   017E
0172:  MOVF   26,W
0174:  SUBLW  62
0176:  BNZ   017E
....................          {  
....................             Garra_desejado=1; 
0178:  BSF    1A.6
....................             z=0; //Zera contador (novo acionamento) 
017A:  BCF    1A.5
....................          } 
....................          //Comando para abrir garra 
....................          else if((char)Aux_0 == 'd' && (char)Aux_1 == 'r' && (char)Aux_2 == 'o' && (char)Aux_3 == 'p')   
017C:  BRA    01F8
017E:  MOVF   23,W
0180:  SUBLW  64
0182:  BNZ   019C
0184:  MOVF   24,W
0186:  SUBLW  72
0188:  BNZ   019C
018A:  MOVF   25,W
018C:  SUBLW  6F
018E:  BNZ   019C
0190:  MOVF   26,W
0192:  SUBLW  70
0194:  BNZ   019C
....................          { 
....................             Garra_desejado=0; 
0196:  BCF    1A.6
....................             z=0; //Zera contador (novo acionamento) 
0198:  BCF    1A.5
....................          } 
....................          //Comando para ligar/desligar lanterna led 
....................          else if((char)Aux_0 == 'l' && (char)Aux_1 == 'u' && (char)Aux_2 == 'z' && (char)Aux_3 == '!')   
019A:  BRA    01F8
019C:  MOVF   23,W
019E:  SUBLW  6C
01A0:  BNZ   01BC
01A2:  MOVF   24,W
01A4:  SUBLW  75
01A6:  BNZ   01BC
01A8:  MOVF   25,W
01AA:  SUBLW  7A
01AC:  BNZ   01BC
01AE:  MOVF   26,W
01B0:  SUBLW  21
01B2:  BNZ   01BC
....................          { 
....................             output_toggle(LedGarra); 
01B4:  BCF    F95.0
01B6:  BTG    F8C.0
....................             z=1; //z deve ser 1 pois após o comando "read" dados não devem ser retornados  
01B8:  BSF    1A.5
....................          } 
....................          //Comando para posição de repouso 
....................          else if((char)Aux_0 == 's' && (char)Aux_1 == 't' && (char)Aux_2 == 'n' && (char)Aux_3 == 'd')    
01BA:  BRA    01F8
01BC:  MOVF   23,W
01BE:  SUBLW  73
01C0:  BNZ   01E6
01C2:  MOVF   24,W
01C4:  SUBLW  74
01C6:  BNZ   01E6
01C8:  MOVF   25,W
01CA:  SUBLW  6E
01CC:  BNZ   01E6
01CE:  MOVF   26,W
01D0:  SUBLW  64
01D2:  BNZ   01E6
....................          { 
....................             Junta0_Desejado = 127; 
01D4:  MOVLW  7F
01D6:  MOVWF  1C
....................             Junta1_Desejado = 127; 
01D8:  MOVWF  1E
....................             Junta2_Desejado = 110; 
01DA:  MOVLW  6E
01DC:  MOVWF  20
....................             Junta3_Desejado = 127; 
01DE:  MOVLW  7F
01E0:  MOVWF  22
....................             z=0; //Zera contador (novo acionamento) 
01E2:  BCF    1A.5
....................          } 
....................          /*Se não são comandos, serão dados de novas posições desejadas: 
....................          Limita extremo inferior** 
....................          Limita extremo superior** 
....................          Atribui nova posição desejada */ 
....................          else                                                              
01E4:  BRA    01F8
....................          { 
....................             z=0; //Zera contador (novo acionamento) 
01E6:  BCF    1A.5
....................             //if (Aux_0 < 50) Junta0_Desejado = 50;            
....................             //else if (Aux_0 > 190) Junta0_Desejado = 190;     
....................             //else  
....................             Junta0_Desejado = Aux_0; 
01E8:  MOVFF  23,1C
....................             //if (Aux_1 < 25) Junta1_Desejado = 25;            
....................             //else if (Aux_1 > 195) Junta1_Desejado = 195; 
....................             //else  
....................             Junta1_Desejado = Aux_1; 
01EC:  MOVFF  24,1E
....................             //if (Aux_2 < 40) Junta2_Desejado = 40; 
....................             //else if (Aux_2 > 250) Junta2_Desejado = 250; 
....................             //else  
....................             Junta2_Desejado = Aux_2; 
01F0:  MOVFF  25,20
....................             //if (Aux_3 < 70) Junta3_Desejado = 70; 
....................             //else if (Aux_3 > 190) Junta3_Desejado = 190; 
....................             //else  
....................             Junta3_Desejado = Aux_3; 
01F4:  MOVFF  26,22
....................          } 
.................... } 
....................  
....................  
01F8:  BCF    F9E.5
01FA:  GOTO   0060
.................... void main () 
.................... {   
01FE:  CLRF   FF8
0200:  BCF    FD0.7
0202:  BSF    07.7
0204:  CLRF   FEA
0206:  CLRF   FE9
0208:  BSF    FB8.3
020A:  MOVLW  08
020C:  MOVWF  FAF
020E:  MOVLW  02
0210:  MOVWF  FB0
0212:  MOVLW  A6
0214:  MOVWF  FAC
0216:  MOVLW  90
0218:  MOVWF  FAB
021A:  MOVLW  04
021C:  MOVWF  19
021E:  BCF    1A.0
0220:  BCF    1A.1
0222:  BCF    1A.2
0224:  BCF    1A.3
0226:  BCF    1A.4
0228:  BSF    1A.5
022A:  BCF    1A.6
022C:  MOVF   FC1,W
022E:  ANDLW  C0
0230:  IORLW  0F
0232:  MOVWF  FC1
0234:  MOVLW  07
0236:  MOVWF  FB4
....................    //Habilitando interrupções 
....................    enable_interrupts(INT_RDA); 
0238:  BSF    F9D.5
....................    enable_interrupts(GLOBAL); 
023A:  MOVLW  C0
023C:  IORWF  FF2,F
....................    /*Setando portas de leitura  
....................    analógica*/ 
....................    SETUP_ADC_PORTS(AN0_TO_AN3); 
023E:  MOVF   FC1,W
0240:  ANDLW  C0
0242:  IORLW  0B
0244:  MOVWF  FC1
....................    SETUP_ADC(ADC_CLOCK_INTERNAL); 
0246:  MOVF   FC0,W
0248:  ANDLW  C0
024A:  IORLW  07
024C:  MOVWF  FC0
024E:  BCF    FC0.7
0250:  BSF    FC2.0
....................    delay_us(20); 
0252:  MOVLW  20
0254:  MOVWF  00
0256:  DECFSZ 00,F
0258:  BRA    0256
025A:  BRA    025C
025C:  NOP   
....................    //Setando pinos como entradas digitais 
....................    output_float(Aberta); 
025E:  BSF    F92.4
....................    output_float(Fechada); 
0260:  BSF    F92.5
....................     
....................    //Setando Led na cor amarela 
....................    output_low(Led_R); 
0262:  BCF    F94.2
0264:  BCF    F8B.2
....................    output_low(Led_G); 
0266:  BCF    F94.1
0268:  BCF    F8B.1
....................    output_high(Led_B); 
026A:  BCF    F94.0
026C:  BSF    F8B.0
....................    //reseta enable's 
....................    output_low(Enable_0); 
026E:  BCF    F95.2
0270:  BCF    F8C.2
....................    output_low(Enable_1); 
0272:  BCF    F95.3
0274:  BCF    F8C.3
....................    output_low(Enable_2); 
0276:  BCF    F94.4
0278:  BCF    F8B.4
....................    output_low(Enable_3); 
027A:  BCF    F94.5
027C:  BCF    F8B.5
....................    //Setando Porto de motores como desligado 
....................    output_low(Junta0E); 
027E:  BCF    F93.7
0280:  BCF    F8A.7
....................    output_low(Junta0D); 
0282:  BCF    F93.6
0284:  BCF    F8A.6
....................    output_low(Junta1E); 
0286:  BCF    F93.5
0288:  BCF    F8A.5
....................    output_low(Junta1D); 
028A:  BCF    F93.4
028C:  BCF    F8A.4
....................    output_low(Junta2E); 
028E:  BCF    F93.3
0290:  BCF    F8A.3
....................    output_low(Junta2D); 
0292:  BCF    F93.2
0294:  BCF    F8A.2
....................    output_low(Junta3E); 
0296:  BCF    F93.1
0298:  BCF    F8A.1
....................    output_low(Junta3D); 
029A:  BCF    F93.0
029C:  BCF    F8A.0
....................    output_low(GarraF); 
029E:  BCF    F95.6
02A0:  BCF    F8C.6
....................    output_low(GarraA); 
02A2:  BCF    F95.7
02A4:  BCF    F8C.7
....................    //Setando led da garra como desligado  
....................    output_low(LedGarra); 
02A6:  BCF    F95.0
02A8:  BCF    F8C.0
....................    /*Atribuindo os valores desejados para as juntas  
....................    como os valores obtidos pela leitura do ADC. 
....................    Isto é feito para que, durante a primeira iteração, 
....................    os valores desejados para as juntas sejam válidos (e não um lixo). 
....................    Uma possibilidade seria definir esses valores iniciais como parâmetros, 
....................    assim toda vez que o sistema fosse iniciado, como primeira tarefa,  
....................    o braço iria para uma posição inicial determinada por esses parâmetros*/ 
....................    set_adc_channel(0); 
02AA:  MOVLW  00
02AC:  MOVWF  01
02AE:  MOVF   FC2,W
02B0:  ANDLW  C3
02B2:  IORWF  01,W
02B4:  MOVWF  FC2
....................    delay_us(20); 
02B6:  MOVLW  20
02B8:  MOVWF  00
02BA:  DECFSZ 00,F
02BC:  BRA    02BA
02BE:  BRA    02C0
02C0:  NOP   
....................    Junta0_Desejado = read_adc(); 
02C2:  BSF    FC2.1
02C4:  BTFSC  FC2.1
02C6:  BRA    02C4
02C8:  MOVFF  FC4,1C
....................    delay_us(20); 
02CC:  MOVLW  20
02CE:  MOVWF  00
02D0:  DECFSZ 00,F
02D2:  BRA    02D0
02D4:  BRA    02D6
02D6:  NOP   
....................     
....................    set_adc_channel(1); 
02D8:  MOVLW  04
02DA:  MOVWF  01
02DC:  MOVF   FC2,W
02DE:  ANDLW  C3
02E0:  IORWF  01,W
02E2:  MOVWF  FC2
....................    delay_us(20); 
02E4:  MOVLW  20
02E6:  MOVWF  00
02E8:  DECFSZ 00,F
02EA:  BRA    02E8
02EC:  BRA    02EE
02EE:  NOP   
....................    Junta1_Desejado = read_adc(); 
02F0:  BSF    FC2.1
02F2:  BTFSC  FC2.1
02F4:  BRA    02F2
02F6:  MOVFF  FC4,1E
....................    delay_us(20); 
02FA:  MOVLW  20
02FC:  MOVWF  00
02FE:  DECFSZ 00,F
0300:  BRA    02FE
0302:  BRA    0304
0304:  NOP   
....................     
....................    set_adc_channel(2); 
0306:  MOVLW  08
0308:  MOVWF  01
030A:  MOVF   FC2,W
030C:  ANDLW  C3
030E:  IORWF  01,W
0310:  MOVWF  FC2
....................    delay_us(20); 
0312:  MOVLW  20
0314:  MOVWF  00
0316:  DECFSZ 00,F
0318:  BRA    0316
031A:  BRA    031C
031C:  NOP   
....................    Junta2_Desejado = read_adc(); 
031E:  BSF    FC2.1
0320:  BTFSC  FC2.1
0322:  BRA    0320
0324:  MOVFF  FC4,20
....................    delay_us(20); 
0328:  MOVLW  20
032A:  MOVWF  00
032C:  DECFSZ 00,F
032E:  BRA    032C
0330:  BRA    0332
0332:  NOP   
....................     
....................    set_adc_channel(3); 
0334:  MOVLW  0C
0336:  MOVWF  01
0338:  MOVF   FC2,W
033A:  ANDLW  C3
033C:  IORWF  01,W
033E:  MOVWF  FC2
....................    delay_us(20); 
0340:  MOVLW  20
0342:  MOVWF  00
0344:  DECFSZ 00,F
0346:  BRA    0344
0348:  BRA    034A
034A:  NOP   
....................    Junta3_Desejado = read_adc(); 
034C:  BSF    FC2.1
034E:  BTFSC  FC2.1
0350:  BRA    034E
0352:  MOVFF  FC4,22
....................    delay_us(20); 
0356:  MOVLW  20
0358:  MOVWF  00
035A:  DECFSZ 00,F
035C:  BRA    035A
035E:  BRA    0360
0360:  NOP   
....................     
....................    while(true) 
....................    { 
....................       ////Acionamento do Motor 0 
....................       // Leitura dos sensores da junta 0 
....................       set_adc_channel(0); 
0362:  MOVLW  00
0364:  MOVWF  01
0366:  MOVF   FC2,W
0368:  ANDLW  C3
036A:  IORWF  01,W
036C:  MOVWF  FC2
....................       delay_us(20); 
036E:  MOVLW  20
0370:  MOVWF  00
0372:  DECFSZ 00,F
0374:  BRA    0372
0376:  BRA    0378
0378:  NOP   
....................       Junta0_Atual = read_adc(); 
037A:  BSF    FC2.1
037C:  BTFSC  FC2.1
037E:  BRA    037C
0380:  MOVFF  FC4,1B
....................       delay_us(20); 
0384:  MOVLW  20
0386:  MOVWF  00
0388:  DECFSZ 00,F
038A:  BRA    0388
038C:  BRA    038E
038E:  NOP   
....................        
....................       if (Junta0_Desejado < Junta0_Atual-Range || Junta0_Desejado > Junta0_Atual+Range)  //Fora do range 
0390:  MOVF   19,W
0392:  SUBWF  1B,W
0394:  SUBWF  1C,W
0396:  BNC   03A2
0398:  MOVF   19,W
039A:  ADDWF  1B,W
039C:  SUBWF  1C,W
039E:  BZ    03C2
03A0:  BNC   03C2
....................       { 
....................          //Seta enable (Provisório -> até que sejam usados PWMs) 
....................          output_high(Enable_0); 
03A2:  BCF    F95.2
03A4:  BSF    F8C.2
....................           
....................          if(Junta0_Desejado < Junta0_Atual-Range)  //Depois do valor desejado 
03A6:  MOVF   19,W
03A8:  SUBWF  1B,W
03AA:  SUBWF  1C,W
03AC:  BC    03B8
....................          {  
....................             output_high(Junta0E);  
03AE:  BCF    F93.7
03B0:  BSF    F8A.7
....................             output_low(Junta0D); 
03B2:  BCF    F93.6
03B4:  BCF    F8A.6
....................          } 
....................          else  //Antes do Valor desejado  
03B6:  BRA    03C0
....................          {  
....................             output_high(Junta0D);  
03B8:  BCF    F93.6
03BA:  BSF    F8A.6
....................             output_low(Junta0E); 
03BC:  BCF    F93.7
03BE:  BCF    F8A.7
....................          } 
....................       } 
....................       else  //Dentro do range 
03C0:  BRA    03D2
....................       { 
....................          //Reseta enable 
....................          output_low(Enable_0); 
03C2:  BCF    F95.2
03C4:  BCF    F8C.2
....................           
....................          output_low(Junta0D);  
03C6:  BCF    F93.6
03C8:  BCF    F8A.6
....................          output_low(Junta0E);  
03CA:  BCF    F93.7
03CC:  BCF    F8A.7
....................          if (a==0) a=1;  //Contador de parada 
03CE:  BTFSS  1A.0
03D0:  BSF    1A.0
....................       } 
....................        
....................       ////Acionamento do Motor 1 
....................       // Leitura dos sensores da junta 1 
....................       set_adc_channel(1); 
03D2:  MOVLW  04
03D4:  MOVWF  01
03D6:  MOVF   FC2,W
03D8:  ANDLW  C3
03DA:  IORWF  01,W
03DC:  MOVWF  FC2
....................       delay_us(20); 
03DE:  MOVLW  20
03E0:  MOVWF  00
03E2:  DECFSZ 00,F
03E4:  BRA    03E2
03E6:  BRA    03E8
03E8:  NOP   
....................       Junta1_Atual = read_adc(); 
03EA:  BSF    FC2.1
03EC:  BTFSC  FC2.1
03EE:  BRA    03EC
03F0:  MOVFF  FC4,1D
....................       delay_us(20); 
03F4:  MOVLW  20
03F6:  MOVWF  00
03F8:  DECFSZ 00,F
03FA:  BRA    03F8
03FC:  BRA    03FE
03FE:  NOP   
....................        
....................       if (Junta1_Desejado < Junta1_Atual-Range || Junta1_Desejado > Junta1_Atual+Range)   //Fora do range 
0400:  MOVF   19,W
0402:  SUBWF  1D,W
0404:  SUBWF  1E,W
0406:  BNC   0412
0408:  MOVF   19,W
040A:  ADDWF  1D,W
040C:  SUBWF  1E,W
040E:  BZ    0432
0410:  BNC   0432
....................       { 
....................          //Seta enable (Provisório -> até que sejam usados PWMs) 
....................          output_high(Enable_1); 
0412:  BCF    F95.3
0414:  BSF    F8C.3
....................           
....................          if(Junta1_Desejado < Junta1_Atual-Range)  //Depois do valor desejado 
0416:  MOVF   19,W
0418:  SUBWF  1D,W
041A:  SUBWF  1E,W
041C:  BC    0428
....................          {  
....................             output_high(Junta1E);  
041E:  BCF    F93.5
0420:  BSF    F8A.5
....................             output_low(Junta1D); 
0422:  BCF    F93.4
0424:  BCF    F8A.4
....................          } 
....................          else  //Antes do valor desejado 
0426:  BRA    0430
....................          {  
....................             output_high(Junta1D);  
0428:  BCF    F93.4
042A:  BSF    F8A.4
....................             output_low(Junta1E); 
042C:  BCF    F93.5
042E:  BCF    F8A.5
....................          } 
....................       } 
....................       else  //Dentro do range  
0430:  BRA    0442
....................       {  
....................          //Reseta enable 
....................          output_low(Enable_1); 
0432:  BCF    F95.3
0434:  BCF    F8C.3
....................           
....................          output_low(Junta1D);  
0436:  BCF    F93.4
0438:  BCF    F8A.4
....................          output_low(Junta1E); 
043A:  BCF    F93.5
043C:  BCF    F8A.5
....................          if (b==0) b=1;  //Contador de parada  
043E:  BTFSS  1A.1
0440:  BSF    1A.1
....................       } 
....................        
....................       ////Acionamento do Motor 2 
....................       // Leitura dos sensores da junta 2 
....................       set_adc_channel(2); 
0442:  MOVLW  08
0444:  MOVWF  01
0446:  MOVF   FC2,W
0448:  ANDLW  C3
044A:  IORWF  01,W
044C:  MOVWF  FC2
....................       delay_us(20); 
044E:  MOVLW  20
0450:  MOVWF  00
0452:  DECFSZ 00,F
0454:  BRA    0452
0456:  BRA    0458
0458:  NOP   
....................       Junta2_Atual = read_adc(); 
045A:  BSF    FC2.1
045C:  BTFSC  FC2.1
045E:  BRA    045C
0460:  MOVFF  FC4,1F
....................       delay_us(20); 
0464:  MOVLW  20
0466:  MOVWF  00
0468:  DECFSZ 00,F
046A:  BRA    0468
046C:  BRA    046E
046E:  NOP   
....................        
....................       if (Junta2_Desejado < Junta2_Atual-Range || Junta2_Desejado > Junta2_Atual+Range)  //Fora do range 
0470:  MOVF   19,W
0472:  SUBWF  1F,W
0474:  SUBWF  20,W
0476:  BNC   0482
0478:  MOVF   19,W
047A:  ADDWF  1F,W
047C:  SUBWF  20,W
047E:  BZ    04A2
0480:  BNC   04A2
....................       { 
....................          //Seta enable (Provisório -> até que sejam usados PWMs) 
....................          output_high(Enable_2); 
0482:  BCF    F94.4
0484:  BSF    F8B.4
....................           
....................          if(Junta2_Desejado < Junta2_Atual-Range)  //Depois do valor desejado  
0486:  MOVF   19,W
0488:  SUBWF  1F,W
048A:  SUBWF  20,W
048C:  BC    0498
....................          {  
....................             output_high(Junta2E);  
048E:  BCF    F93.3
0490:  BSF    F8A.3
....................             output_low(Junta2D); 
0492:  BCF    F93.2
0494:  BCF    F8A.2
....................          } 
....................          else  //Antes do valor desejado  
0496:  BRA    04A0
....................          {  
....................             output_high(Junta2D);  
0498:  BCF    F93.2
049A:  BSF    F8A.2
....................             output_low(Junta2E); 
049C:  BCF    F93.3
049E:  BCF    F8A.3
....................          } 
....................       } 
....................       else  //Dentro do range  
04A0:  BRA    04B2
....................       {   
....................          //Reseta enable 
....................          output_low(Enable_2); 
04A2:  BCF    F94.4
04A4:  BCF    F8B.4
....................           
....................          output_low(Junta2D);  
04A6:  BCF    F93.2
04A8:  BCF    F8A.2
....................          output_low(Junta2E);  
04AA:  BCF    F93.3
04AC:  BCF    F8A.3
....................          if (c==0) c=1; //Contador de parada 
04AE:  BTFSS  1A.2
04B0:  BSF    1A.2
....................       } 
....................        
....................       ////Acionamento do Motor 3 
....................       // Leitura dos sensores da junta 3 
....................       set_adc_channel(3); 
04B2:  MOVLW  0C
04B4:  MOVWF  01
04B6:  MOVF   FC2,W
04B8:  ANDLW  C3
04BA:  IORWF  01,W
04BC:  MOVWF  FC2
....................       delay_us(20); 
04BE:  MOVLW  20
04C0:  MOVWF  00
04C2:  DECFSZ 00,F
04C4:  BRA    04C2
04C6:  BRA    04C8
04C8:  NOP   
....................       Junta3_Atual = read_adc(); 
04CA:  BSF    FC2.1
04CC:  BTFSC  FC2.1
04CE:  BRA    04CC
04D0:  MOVFF  FC4,21
....................       delay_us(20); 
04D4:  MOVLW  20
04D6:  MOVWF  00
04D8:  DECFSZ 00,F
04DA:  BRA    04D8
04DC:  BRA    04DE
04DE:  NOP   
....................        
....................       if (Junta3_Desejado < Junta3_Atual-Range || Junta3_Desejado > Junta3_Atual+Range)  //Fora do range 
04E0:  MOVF   19,W
04E2:  SUBWF  21,W
04E4:  SUBWF  22,W
04E6:  BNC   04F2
04E8:  MOVF   19,W
04EA:  ADDWF  21,W
04EC:  SUBWF  22,W
04EE:  BZ    0512
04F0:  BNC   0512
....................       { 
....................          //Seta enable (Provisório -> até que sejam usados PWMs) 
....................          output_high(Enable_3); 
04F2:  BCF    F94.5
04F4:  BSF    F8B.5
....................           
....................          if(Junta3_Desejado < Junta3_Atual-Range)  //Depois do valor desejado  
04F6:  MOVF   19,W
04F8:  SUBWF  21,W
04FA:  SUBWF  22,W
04FC:  BC    0508
....................          {  
....................             output_high(Junta3E); 
04FE:  BCF    F93.1
0500:  BSF    F8A.1
....................             output_low(Junta3D); 
0502:  BCF    F93.0
0504:  BCF    F8A.0
....................          } 
....................          else  //Antes do valor desejado  
0506:  BRA    0510
....................          {  
....................             output_high(Junta3D);  
0508:  BCF    F93.0
050A:  BSF    F8A.0
....................             output_low(Junta3E); 
050C:  BCF    F93.1
050E:  BCF    F8A.1
....................          } 
....................       } 
....................       else  //Dentro do range  
0510:  BRA    0522
....................       {  
....................          //Reseta enable 
....................          output_low(Enable_3); 
0512:  BCF    F94.5
0514:  BCF    F8B.5
....................           
....................          output_low(Junta3D);  
0516:  BCF    F93.0
0518:  BCF    F8A.0
....................          output_low(Junta3E);  
051A:  BCF    F93.1
051C:  BCF    F8A.1
....................          if (d==0) d=1;  //Contador de parada  
051E:  BTFSS  1A.3
0520:  BSF    1A.3
....................       } 
....................        
....................       ////Acionamento da Garra 
....................       if (Garra_desejado==1 && input(Fechada)!=0)   //Quer fechar mas ainda não fechou 
0522:  BTFSS  1A.6
0524:  BRA    0536
0526:  BSF    F92.5
0528:  BTFSS  F80.5
052A:  BRA    0536
....................       { 
....................          output_high (GarraF); 
052C:  BCF    F95.6
052E:  BSF    F8C.6
....................          output_low (GarraA); 
0530:  BCF    F95.7
0532:  BCF    F8C.7
....................       } 
....................       else if (Garra_desejado==0 && input(Aberta)!=0)   //Quer abrir mas ainda não abriu 
0534:  BRA    0554
0536:  BTFSC  1A.6
0538:  BRA    054A
053A:  BSF    F92.4
053C:  BTFSS  F80.4
053E:  BRA    054A
....................       { 
....................          output_high (GarraA); 
0540:  BCF    F95.7
0542:  BSF    F8C.7
....................          output_low (GarraF); 
0544:  BCF    F95.6
0546:  BCF    F8C.6
....................       } 
....................       else  //Não quer fechar nem abrir 
0548:  BRA    0554
....................       { 
....................          output_low (GarraF); 
054A:  BCF    F95.6
054C:  BCF    F8C.6
....................          output_low (GarraA); 
054E:  BCF    F95.7
0550:  BCF    F8C.7
....................          e=1;  //Contador de parada 
0552:  BSF    1A.4
....................       } 
....................        
....................       //Comunicação e sinalização de parada 
....................       if (a==1 && b==1 && c==1 && d==1 && e==1)  //Todos os sensores já chegaram  
0554:  BTFSS  1A.0
0556:  BRA    057E
0558:  BTFSS  1A.1
055A:  BRA    057E
055C:  BTFSS  1A.2
055E:  BRA    057E
0560:  BTFSS  1A.3
0562:  BRA    057E
0564:  BTFSS  1A.4
0566:  BRA    057E
....................       { 
....................          if(z==0)                // O 'z' somente será zero quando um novo dado chegar no buffer  
0568:  BTFSC  1A.5
056A:  BRA    057E
....................          {                      //e este for um dado de posicionamento 
....................             printf("OK"); 
056C:  MOVLW  4F
056E:  BTFSS  F9E.4
0570:  BRA    056E
0572:  MOVWF  FAD
0574:  MOVLW  4B
0576:  BTFSS  F9E.4
0578:  BRA    0576
057A:  MOVWF  FAD
....................             z=1; 
057C:  BSF    1A.5
....................          } 
....................       } 
....................        
....................       if (z==0) 
057E:  BTFSC  1A.5
0580:  BRA    0590
....................       { 
....................          output_low(Led_R);            //Aciona led na cor vermelha 
0582:  BCF    F94.2
0584:  BCF    F8B.2
....................          output_high(Led_G); 
0586:  BCF    F94.1
0588:  BSF    F8B.1
....................          output_high(Led_B); 
058A:  BCF    F94.0
058C:  BSF    F8B.0
....................       } 
....................       else 
058E:  BRA    059C
....................       { 
....................          output_high(Led_R);            //Aciona led na cor verde 
0590:  BCF    F94.2
0592:  BSF    F8B.2
....................          output_low(Led_G); 
0594:  BCF    F94.1
0596:  BCF    F8B.1
....................          output_high(Led_B); 
0598:  BCF    F94.0
059A:  BSF    F8B.0
....................       } 
....................    } 
059C:  BRA    0362
.................... } 
059E:  SLEEP 

Configuration Fuses:
   Word  1: CC20   PLL1 CPUDIV1 USBDIV HS FCMEN IESO
   Word  2: 0E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT128
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
